## Как перенести мастер на новый сервер без даунтайма

Рассмотрим вариант когда нам нужно перенести связку матер-слейв на другую пару хостов. Допустим есть такая конфигурация, когда запросы на запись идут на мастер, а на чтение и на мастер и на слейв:

```
     ----- php -----
     |              | (readonly)
     ᐯ             ᐯ
old:master <- old:slave
```
Стрелка от слейва к мастеру, означает что слейв вычитывает данные из мастера. Возможен и обратный вариант, но на практике мы его не используем (он хоть и более быстрый, но без гарантий консистентности).

Сначала на хосте, который будет новым мастером, нужно развернуть еще один слейв:
```
     ----- php -----
     |              |
     ᐯ             ᐯ
old:master <- old:slave
     ^
     |
new:master( as slave.conf )
```
Разумееться перед этим нужно залить базу с old:master (см. [репликация](replication.md))
Убеждаемся, что репликация идет стабильно и перезапускаем демон в режиме master-salve:
```bash
./slave.sh stop
./master-slave.sh start
```
Если вы перезаливали через API, то у вас остался запущен демон с другой конфигурацией, поэтому:
```bash
./slave-reload.sh stop
./master-slave.sh start
```

В этом режиме сервер работает и как мастер и как слейв, т.е. к нему можно подключать к слейвы. Обычные слейвы настроены так, что к ним нельзя подключать слейвы из соображений производительности. В режиме master-salve будущего мастера, мы подключаем новый слейв. Примерно это будет так:

```
     ----- php -----
     |              |
     ᐯ             ᐯ
old:master <- old:slave
     ^
     |
new:master( as master-slave.conf ) <- new:slave (as slave.conf)
```
Сейчас нагрузка идет на старые мастер и слейв, но новые мастер и слейв содержат актуальные данные. Далее нужно поставить задачу тех. поддержке, чтобы они переключили нагрузку на новый мастер и слейв:
```
old:master <- old:slave
     ^
     |
new:master( as master-slave ) <- new:slave
    ^                                ^
    |                                |
     ----- php -----------------------
```
Убеждаемся, что все работает корректно, и перезапускаем новый мастер из режима мастер-слейв в просто в мастер режим:
```bash
./master-slave.sh stop
./master.sh start
```

```
old:master <- old:slave
    
new:master <- new:slave
    ^               ^
    |               |
     ----- php -----
```
Далее старую связку можно отключать.

## Особенности перезаливки базы при миграции


### По шагам 

* Убеждаемся, что old:master запущен как мастер (с конфигурацией master.conf)
* На new:master изменяем поле addr в **client-tcp** на реальный ip-адрес `<<old:master>>` в `master-slave.conf`
* На new:master запускаем `./rsync-db.sh <<old:master addr>> 3600` для копирования базы. Здесь 3600 предполагаемое время в секундах необходимое для копирования. На это время мастер перстает производить запись на диск.  
* На new:master запускаем `./master-slave.sh start`
* Сейчас на new:master работает слейв для old:master'а
* Делаем деплой на new:slave
* На new:slave запускаем `./rsync-db.sh <<new:master>> 3600` для копирования базы 
* На new:slave изменяем addr в **client-tcp** на` <<new:master>>` в `slave.conf`
* На new:slave запускаем `./slave.sh start`
* Работает цепочка `old:master`->`new:master`->`new:slave`
* Переключаем нагрузку php на связку `new:master`->`new:slave`
* На new:master запускаем `master-slave.sh stop` останавлием режим репликации c `old:master`
* На new:master запускаем `master.sh start` запускаем без репликации c `old:master`
* Можно выключать `old:master` и `old:slave`

Если мастер не мастер (репликация не нужна). То на old:master нужно перезапустить как `master`:
```bash
./prefixdb.sh stop
./master.sh start
```

Далее делать все тоже самое, только не разворачивать slave, в в конце перезапускаем его на new:master так:
```bash
./master-slave.sh stop
./prefixdb.sh start
```

Аналогично на на old:master возвращаем без поддержки репликации
```bash
./master.sh stop
./prefixdb.sh start
```

### Для версии old:master 0.9.0 и 0.9.1

Здесь почти все тоже самое, скорее всего регламент портов соблюден. Но скорее всего здесь не будет набора скриптов запуска и соответствующих конфигураций. Поэтому чтобы убедиться, что мастер работает в режиме мастера, нужно посмотреть `rocksdb.ini`, где `WAL_ttl_seconds=7200` ну или другое отличное от нуля. При необходимости внести изменения и перезапустить

### Для версии old:master ниже 0.9.0 

Если `./prefixdbd -v`, если падает с ошибкой `error while loading shared libraries` то это однозначно этот случай. Версию можно посмотреть `./prefixdb-exec.sh -v`

Для этих версий еще не перешли на регламент портов, там другая логика была. Поэтому нужно на old:master в конфигурации найти порт для слейва и изменить его на new:master  в секции **client-tcp** в конфигурациях`slave.conf`, `master-slave.conf` и `slave-reload.conf`.

Более того, там работает RocksDB без поддержки TTL, который не совместима с версией с TTL, поэтому простым копированием файлов не перезалить базу. Но PrefixDB умеет перезаливать базу сам, через API, хотя может это делать значительно дольше. Для этого в конфигурации `slave-reload.conf` нужно задать актуальные адрес и порт мастера, который запущен на old:master, и запустить prefixdb с этой конфигурацией:
```bash
./slave-reload.sh start
```
Далее нужно следить за лог-файлом, пока там не перестанут идти записи типа:
```bash
2021-03-16 23:17:08.048 PrefixDB MESSAGE   Initial load...
```
В общем можно так и оставить на неопределенное время, после загрузки демон будет работать в режиме слейва, но лучше не оставлять его так на более чем несколько дней и перезапустить с другой конфигурацией, скорее всего вам нужно будет сделать так:
```bash
./slave-reload.sh stop
./master-slave.sh start
```
**ВАЖНО** перезапуск `./slave-reload.sh restart` приведет к вычитыванию всей базы заного! 

